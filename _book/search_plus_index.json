{"./":{"url":"./","title":"GitBook教程","keywords":"","body":"简介 本书是个人的开发笔记.用于知识点学习和总结. ios的oc,swift react-native的react,javascript nodejs electron 注意: 虽然目标明确,可日常生活过于散漫,导致进程遥遥无期,也就是传说中的拖延症.希望此次能让病情有所缓解. @xclidongbo all right reserved，powered by Gitbook该文件最后修改时间： 2020-04-16 23:19:33 "},"doc/gitbook/":{"url":"doc/gitbook/","title":"简介","keywords":"","body":"gitbook简介 gitBook文档 GitBook文档 GitBook开发手册 gitbook创建 gitbook-cli和gitbook是两个命令 npm install gitbook-cli -g git init创建文件: README.md(默认) SUMMARY.md(文件的目录) 文档书写 创建book.json文件,指定readme文件的位置. { \"title\": \"我的一本书\", \"author\" : \"李东波\", \"description\" : \"我第一本书的描述，很好\", \"language\" : \"zh-hans\", \"structure\": { \"readme\": \"README.md\" } } 封面 封面由 cover.jpg 文件指定，cover_small.jpg 同样可以作为小版本封面存在。封面应该是 JPEG 格式的文件。 大 小 文件 cover.jpg cover_small.jpg 大小(像素) 1800*2360 200*262 pdf/epub/mobi格式 calibre mobi格式,执行 gitbook mobi . 左侧导航栏添加链接信息 \"links\" : { \"sidebar\" : { \"Home\" : \"http://zhangjikai.com\" } } 自定义页面样式 \"styles\": { \"website\": \"styles/website.css\", \"ebook\": \"styles/ebook.css\", \"pdf\": \"styles/pdf.css\", \"mobi\": \"styles/mobi.css\", \"epub\": \"styles/epub.css\" } 插件 配置使用插件 \"plugins\": [ \"disqus\" ] 然后使用gitbook install来安装新插件 去除自带插件 \"plugins\": [ \"-search\" ] 配置插件属性 \"pluginsConfig\": { \"fontsettings\": { \"theme\": \"sepia\", \"family\": \"serif\", \"size\": 1 } } structure 指定 Readme、Summary、Glossary 和 Languages 对应的文件名，下面是这几个文件对应变量以及默认值： |变量|含义和默认值| |-|-| |structure.readme|Readme file name (defaults to README.md)| |structure.summary |Summary file name (defaults to SUMMARY.md)| |structure.glossary |Glossary file name (defaults to GLOSSARY.md)| |structure.languages |Languages file name (defaults to LANGS.md)| @xclidongbo all right reserved，powered by Gitbook该文件最后修改时间： 2020-04-15 23:28:36 "},"doc/javascript/":{"url":"doc/javascript/","title":"JavaScript","keywords":"","body":"JavaScript实现 JavaScript包含: The Core(ECMAScript) DOM BOM @xclidongbo all right reserved，powered by Gitbook该文件最后修改时间： 2020-04-15 23:28:36 "},"doc/javascript/basics/":{"url":"doc/javascript/basics/","title":"基础","keywords":"","body":"@xclidongbo all right reserved，powered by Gitbook该文件最后修改时间： 2020-04-15 23:28:36 "},"doc/javascript/basics/variable.html":{"url":"doc/javascript/basics/variable.html","title":"变量","keywords":"","body":"声明 let sum = a + b //没有分号, 不推荐 let diff = a - b; //推荐 // 有效,但容易出错,不推荐 if (test) console.log(test); //推荐 if (test) { console.log(test);} 变量 var message = 'hi'; var 声明范围 局部变量 function test() { var message = \"hi\"; // local variable } test(); console.log(message);//错误 全局变量 function test() { message = \"hi\"; // global variable } test(); console.log(message); // \"hi” var声明提升 //可以重复声明不报错 function foo() { var age = 16; var age = 26; var age = 36; console.log(age); } foo(); // 36 let声明 只在作用域内有用.不能重复声明 临时死区 全局声明 var name = 'Matt'; console.log(window.name); // 'Matt' let age = 26; console.log(window.age); // undefined 在循环中的let声明 for (let i = 0; i const声明 const声明后,值不能重新定义. const声明仅仅强制指向它的指针指向.如果一个const变量指向一个对象,改变对象的属性并不违反原则. const person = {}; person.name = 'Matt'; // ok 声明的样式和最好的练习 不要使用var 偏爱const多于let @xclidongbo all right reserved，powered by Gitbook该文件最后修改时间： 2020-04-15 23:28:36 "},"doc/javascript/basics/data_types.html":{"url":"doc/javascript/basics/data_types.html","title":"数据类型","keywords":"","body":"数据类型 typeof操作符 typeof XXX undefined boolean string number object function symbol undefined类型 Null类型 Null类型只有一个特殊值: null. null是一个空对象指针.typeof null 返回的是是 object. let car = null; console.log(typeof car); // \"object” undefined是null的子类. 所以以下等式成立 console.log(null == undefined); // true Boolean类型 数据类型 为true 为false Boolean true false String 非空字符串 \"\"(空字符串) Number 非0数字 0,NaN Object 任意对象 null Undefined n/a undefined @xclidongbo all right reserved，powered by Gitbook该文件最后修改时间： 2020-04-15 23:28:36 "},"doc/react-native/":{"url":"doc/react-native/","title":"ReactNative","keywords":"","body":"React Native概述 为什么选择React? React的开发者采取了虚拟DOM的做法,虚拟DOM更加轻量,对真实DOM抽象化.独立于特定浏览器的具体实现.每当触发需要改变的DOM事件时, React会创建一个新的虚拟DOM树,与已有的树进行对比,计算出最少的DOM变化集合,把它们放入队列再全部执行,重新渲染.这种做法比直接操作DOM快了很多. 开发简单, 声明式编程: 按照设计稿编写声明式视图，定义应用的状态。React会根据应用状态，仅更新、渲染对应的组件，非常高效。这让代码的编写和维护变得非常容易，同时更具可预测性，更容易调试。 组件化开发: 用了React，你只需要开发组件。开发一整套组件，再把它们拼装成应用。 工作原理: 将UI拆解成组件: 交互式UI. 为什么选择React Native? React Native允许开发者通过JavaScript函数的代理, 直接调用原生模块.使用React Native,会得到原生的用户体验以及Web的开发体验. 简单易学: 上手难度低,只要学会React,就会上手开发界面,如果会移动端的开发,更是锦上添花; 快速迭代: 不用等待应用编译,通过热重载,就能快速显示UI; 智能调试: React Native会在报错时,抛出错误描述; 原生模块: 可以自定义原生模块,提供完整能力; 一次学习,全平台开发: 可以为任何平台开发应用,但需为每个平台提供基础的技术支持. RN需要一个JS运行环境, 在iOS上直接使用内置的javascriptcore, 在Android上则使用webkit.org官方提供的jsc.so.此外还集成了其它开源组件,如fresco图片组件,okhttp网络组件等. 对于JS开发者来说,画UI只需要使用React来做, 不需要特别关心具体的平台.以iOS为例, JavaScript的形式告诉Objective-C需要执行什么,然后iOS自己去调用UIKit等框架绘制界面. 所以,React Native能运行起来,全靠Objective-C和JavaScript的交互. React Native的工作原理 原生代码和JavaScript代码通过桥接层进行交互, 这是一个异步的批量串行处理过程. 桥接层介于原生层和JavaScript代码之间,正如它的名称一样,作用是桥接.用户输入,计时器,网络请求和响应等在原生代码中.React Native在原生层收集事件产生的数据,串行处理后通过桥接层传给JavaScript层, JS层拿到数据后处理并生成一系列指令.同样经过批量串行处理后传回原生层.桥接层的原生端决定哪个模块负责处理传回的指令并调用相应的方法,在需要的情况下更新UI. @xclidongbo all right reserved，powered by Gitbook该文件最后修改时间： 2020-04-15 23:28:36 "},"doc/TypeScript/":{"url":"doc/TypeScript/","title":"TypeScript","keywords":"","body":"TypeScript是JavaScript的一个超集.主要提供了系统类型对ES6的支持. 优势: 增加了代码的可读性,可维护性; 类型系统是最好的文档,看类型定义就知道如何使用; 可以编译期发现大部分错误; 增强了编辑器和IDE的功能. 非常包容; 可以作出类型推论; 可以定义从简单到复杂的几乎一切类型; 即使TypeScript编译报错,也能生成JS文件 兼容第三方库. 拥有活跃的社区 缺点: 有学习成本,需要理解接口(interfaces),泛型(Generics),类(Classess),枚举类(Enums) 短期可能会增加一些开发成本,不过对于一个长期维护的项目,TS能减少维护成本; 集成到构建流程需要一些工作量; 可能和一些库结合的不是很完美. @xclidongbo all right reserved，powered by Gitbook该文件最后修改时间： 2020-04-16 23:40:17 "},"doc/TypeScript/DataTypes.html":{"url":"doc/TypeScript/DataTypes.html","title":"原始数据类型","keywords":"","body":"原始数据类型 JavaScript的类型分为两种: 原始数据类型 布尔 数值 字符串 null undefined Symbol 对象类型 布尔值 let isDone: boolean = false; 数值 let dec: number = 6; 字符串 let myName: string = 'tom' 空值 void代表没有任何返回值的函数 Null和Undefined undefined 和 null是所有类型的子类型 let num: number = undefined; @xclidongbo all right reserved，powered by Gitbook该文件最后修改时间： 2020-04-19 22:41:34 "},"doc/TypeScript/Any.html":{"url":"doc/TypeScript/Any.html","title":"任意值","keywords":"","body":"Any任意值 概念 Any表示允许复制为任何类型 如果是一个普通类型, 在赋值过程中改变类型是不被允许的;如果是any,则允许被赋值为任意类型 let myFav: any = 'tom'; myFav = 7; 任意值的属性和方法 在任意值上访问任何属性都是允许的: let anyThing: any = 'hello'; console.log(anyThing.myName); console.log(anyThing.myName.firstName); 也允许调用任何方法: let anyThing: any = 'Tom'; anyThing.setName('Jerry'); 声明一个变量为任意值后,对它任何操作,返回的内容的类型都是任意值. 未声明类型的变量 变量如果在声明的时候,未指定其类型,那么它会被识别为任意值类型: let something; something = 'seven'; something = 7; something.setName('Tom'); 等价于 let something: any; @xclidongbo all right reserved，powered by Gitbook该文件最后修改时间： 2020-04-19 22:41:56 "},"doc/TypeScript/TypeInference.html":{"url":"doc/TypeScript/TypeInference.html","title":"类型推断","keywords":"","body":"类型推论 如果没有明确指明类型,那么TypeScript会依照类型推论的规则推断出一个类型 如: let myFav = 'seven'; let myFav: string = 'seven' 如果定义的时候没有赋值, 就是any类型而不被类型检查 @xclidongbo all right reserved，powered by Gitbook该文件最后修改时间： 2020-04-19 22:43:02 "},"doc/TypeScript/UnionTypes.html":{"url":"doc/TypeScript/UnionTypes.html","title":"联合类型","keywords":"","body":"联合类型 let myFav: string | number; myFav = 'seven'; myFav = 7; 访问联合类型的属性或者方法 当TypeScript不确定一个联合类型的变量到底是哪个类型的时候,我们只能访问联合类型里共有的属性和方法 联合类型的变量在被赋值的时候, 会根据类型推断的规则,推断出一个类型. @xclidongbo all right reserved，powered by Gitbook该文件最后修改时间： 2020-04-19 22:43:08 "},"doc/TypeScript/Interfaces.html":{"url":"doc/TypeScript/Interfaces.html","title":"对象的类型-接口","keywords":"","body":"接口 概念 接口是对行为的抽象,具体如何行动需要由类去实现. interface Person { name: string; age: number; } let tom: Person = { name: 'Tom', age: 25 } 定义的变量比接口少一些或者多一些属性是不被允许的: interface Person { name: string; age: number; } let tom: Person = { name: 'Tom' } 可选属性 有时我们希望不要完全匹配一个形状,那么可以用可选属性: interface Person { name: string; age?: number; } let tom: Person = { name: 'Tom' } 可选属性的含义是该属性可以不存在 但这时候依然不允许添加未定义的属性. 任意属性 我们希望一个接口允许有任意的属性 interface Person { name: string; age?: number; [propName: string]: any; } let tom: Person = { name: 'Tom', gender: 'male' } 一旦定义了任意属性,那么确定属性和可选属性必须是任意属性的子集. let tom: Person = { name: 'Tom'; age: 25; gender: 'male' } // 报错, 任意属性的值允许是string,但可选属性age却是number,number不是string的子集,所以报错. 一个接口只能定义一个任意属性,如果接口中有多个类型的属性,则可以在任意属性中使用联合类型. interface Person { name: string; age?: number; [propName: string]: string | number; } let tom: Person = { name: 'Tom', age: 25, gender: 'male' }; 只读属性 有时候我们希望对象中的一些字段只在创建的时候被赋值,那么可以用readonly定义只读属性 interface Person { readonly id: number; name: string; age?: number; [propName: string]: any; } 只读的约束存在于第一次给对象赋值的时候,而不是第一次给只读属性赋值的时候. @xclidongbo all right reserved，powered by Gitbook该文件最后修改时间： 2020-04-19 22:42:54 "},"doc/TypeScript/ArrayTypes.html":{"url":"doc/TypeScript/ArrayTypes.html","title":"数组的类型","keywords":"","body":"数组的类型 类型+方括号 let fib: number[] = [1,2,3,4] 数组的项中不允许出现其它类型 数组泛型 我们也可以使用数组泛型来表示数组 let fib: Array = [1,2,3,4]; 用接口表示数组 interface NumberArray { [index: number]: number; } let fib: NumberArray = [1,2,3,4] NumberArray表示: 只要索引的类型是数字时, 那么值的类型必须是数字 类数组 类数组不是数组类型 function sum() { let args: number[] = arguments; } //以上会报错 function sum() { let args: { [index: number]: number; length: number; callee: Function; } = arguments; } any在数组中的应用 let list: any[] = ['liu', 25, {website: 'http://www.baidu.com'}] @xclidongbo all right reserved，powered by Gitbook该文件最后修改时间： 2020-04-19 22:42:02 "},"doc/TypeScript/FunctionTypes.html":{"url":"doc/TypeScript/FunctionTypes.html","title":"函数的类型","keywords":"","body":"函数类型 函数声明 // 函数声明 function sum(x, y) { return x+y; } // 函数表达式 let mySum = function (x,y) { return x+y; }; function sum(x: number, y: number): number { return x+y; } 函数表达式 let mySum = function (x: number, y: number): number { return x + y; } //等价于 let mySum: (x: number, y: number) => number = function (x: number, y: number):number { return x+ y; } 用接口定义函数的形状 interface SearchFunc { (source: string, subString: string): boolean; } let mySearch: SearchFunc; mySearch = function(source: string, subString: string) { return source.search(subString) !== -1; } 可选参数 function buildName(firstName: string, lastName?: string) { if (){ return firstName + ' ' + lastName; } else{ return firstName; } } let tomcat = buildName('Tom', 'Cat'); let tom = buildName('Tom') 可选参数后面不允许再出现必需参数. 参数默认值 function buildName(firstName: string, lastName: string = 'Cat') { return firstName + ' ' + lastName; } let tomcat = buildName('Tom', 'Cat'); let tomcat = buildName('Tom'); 剩余参数 function push(array, ...items) { items.forEach(function(item) { array.push(item); }) } let a: any[] = [];--- push(a,1,2,3) 重载 重载允许一个函数接受不同数量或类型的参数,作出不同处理. 利用联合类型, 我们可以这么实现: function reverse(x: string|number): number|string { if (typeof x === 'number') { return Number(x.toString().split('').reverse().join('')); }else if (typeof x === 'string') { return x.split('').reverse().join(''); } } 我们也可以使用重载定义多个reverse的函数类型 function reverse(x: number): number; function reverse(x: string): string; function reverse(x: number | string): number | string { if (typeof x === 'number') { return Number(x.toString().split('').reverse().join('')); } else if (typeof x === 'string') { return x.split('').reverse().join(''); } } @xclidongbo all right reserved，powered by Gitbook该文件最后修改时间： 2020-04-19 22:42:26 "},"doc/electron/":{"url":"doc/electron/","title":"Electron","keywords":"","body":"@xclidongbo all right reserved，powered by Gitbook该文件最后修改时间： 2020-04-16 23:19:57 "},"doc/iOS/":{"url":"doc/iOS/","title":"iOS","keywords":"","body":"@xclidongbo all right reserved，powered by Gitbook该文件最后修改时间： 2020-04-15 23:28:36 "},"doc/iOS/background_task.html":{"url":"doc/iOS/background_task.html","title":"后台任务","keywords":"","body":"iOS的后台保活 iOS可以做到后台保活. 短时间保活方式有beginBackgroundTaskWithName; App长时间保活方式有: 播放无声音乐,后台持续定位,后台下载资源,BGTaskScheduler等 唤醒App的方式: 推送,VoIP等 App运行状态及状态变化 iOS13+的设备,支持多场景,共有: unattached: 多个场景的情况,如果创建的场景不是当前显示的场景,那么场景处于unattached状态; Foreground Inactive:应用启动后,显示启动图的过程中; Foreground Active:应用启动后,显示出来我们设置的rootViewController之后; Foreground Inactive:应用启动后,场景处于显示状态,数据加载完毕,且用户和App没有交互过程中; Background:用户点击Home,或者切换App,锁屏后; Suspended:进入Background后,应用的代码不执行后,应用进入Suspended状态;(代码是否在运行,可以在应用写定时器,定时输出内容,从Xcode控制台,或者Mac端控制台查看是否有输出内容来判断); 低于iOS13的设备,app的运行状态: Not Running:用户没有启动App,或者Terminate App后,App处于的状态; Foreground Inactive:(同上); Foreground Active:(同上); Foreground Inactive:(同上); Background:(同上); Suspended:(同上); iOS后台保活方式简介 短时间App后台保活 beginBackgroundTaskWithName和endBackgroundTask 系统低于iOS13的设备,后台运行时间3分钟; 系统高于iOS13的设备,后台运行时间约31秒; 播放无声音乐 App进入后台后,播放无声音乐,适用于音视频类App. 后台持续定位 对于定位类App,持续定位App,可以实现App 后台保活. 后台下载资源 对于要下载资源的App,需要后台下载资源,比如我们在某App下载资源的时候,我们希望切换App时候,或者App退出后台后,资源仍然继续下载,这样我们打开App的时候,资源已经下载好了. BackgroundTasks BackgroundTasks.framework是iOS13新增的framework. @xclidongbo all right reserved，powered by Gitbook该文件最后修改时间： 2020-04-15 23:28:36 "}}